// Code generated by PromptDSL. DO NOT EDIT.
package generated

import (
	"encoding/json"
	"fmt"
	"os"
	"service"
	"strings"
)

type SplitSolutionStepsInputContext struct {
    Question string `json:"Question"`
    Process string `json:"Process"`
}

type SplitSolutionStepsOutputContext struct {
    Conditions []string `json:"条件"`
    KnowledgePoint string `json:"知识点"`
    ProcessResult string `json:"问题"`
}

type SplitSolutionStepsFinalContext struct {
    Input  SplitSolutionStepsInputContext
    Output []SplitSolutionStepsOutputContext
}

func SplitSolutionSteps_GenSys(input SplitSolutionStepsInputContext) string {
    var b strings.Builder
    b.WriteString("你是一个擅长拆分解题步骤的数学老师\n")
    if (input.Question=="") {
        b.WriteString("当前任务是将解题步骤进行合理拆分\n")
    } else {
        b.WriteString("当前任务是将解题步骤进行合理拆分2\n")
    }
    return b.String()

}

func SplitSolutionSteps_GenUser(input SplitSolutionStepsInputContext) string {
    var b strings.Builder
    b.WriteString("请根据以下输入题目及其解答内容，将完整的解答过程拆分为多个“短链”，每个“短链”包含以下三个要素：\n")
    if (input.Question!="") {
        b.WriteString("你好\n")
    } else {
        b.WriteString("siuehfebn\n")
    }
    for _,u:= range input.Process {
        fmt.Println(u)
        b.WriteString(u)
    }
    b.WriteString("条件，知识点，结果\n")
    b.WriteString("题目：\n")
    b.WriteString(input.Question)
    b.WriteString("过程：\n")
    b.WriteString(input.Process)
    b.WriteString("请将输出内容严格按照以下格式返回：\n")
    b.WriteString("```json\n")
    b.WriteString("[\n")
    b.WriteString("  {\n")
    b.WriteString("    \"条件\": [\"\"]  // 严格遵守以下规定设计数学公式使用标准通用的latex格式,数学公式以美元符号包裹，$或$$与公式内容之间不允许有任何空格,\n")
    b.WriteString("    \"知识点\": \"\"  // 严格遵守以下规定设计数学公式使用标准通用的latex格式,数学公式以美元符号包裹，$或$$与公式内容之间不允许有任何空格,\n")
    b.WriteString("    \"问题\": \"\"  // 严格遵守以下规定设计数学公式使用标准通用的latex格式,数学公式以美元符号包裹，$或$$与公式内容之间不允许有任何空格\n")
    b.WriteString("  }\n")
    b.WriteString("]\n")
    b.WriteString("```\n")

    b.WriteString("特别提醒：本题可能涉及 extra_hint，请根据步骤合理提取对应知识点。\n")
    return b.String()

}

func SplitSolutionSteps_AfterProcess(output []SplitSolutionStepsOutputContext) []SplitSolutionStepsOutputContext {

        trueCount := 0
        for _, item := range output {
            if item.KnowledgePoint!= "" {
                trueCount++
            }
        }
        return output
    
}

func SplitSolutionSteps_FixProcess(response string) ([]SplitSolutionStepsOutputContext ,error){

        // 用strings.Builder手动替换单反斜杠
        fmt.Println("response:", response)
        var results []SplitSolutionStepsOutputContext
        err := json.Unmarshal([]byte(response), &results)
        return results, err
    
}

func SplitSolutionSteps(input SplitSolutionStepsInputContext) ([]SplitSolutionStepsOutputContext,error) {
    fmt.Fprintln(os.Stderr, "[main] 程序启动，等待输入...")
    sys := SplitSolutionSteps_GenSys(input)
    user := SplitSolutionSteps_GenUser(input)
    apiKey := "sk-02e496929ecc485796d29bd94e7ce371"
    llm := service.NewLLMClient(apiKey)
    result, err := llm.GeneratePromptResponse(sys, user)
    if err != nil {
        fmt.Fprintf(os.Stderr, "调用大模型失败: %v\n", err)
        os.Exit(1)
    }
    output, err := SplitSolutionSteps_FixProcess(result)
    if err != nil {
        fmt.Fprintf(os.Stderr, "解析输入 JSON 失败011111: %v\n", err)
        os.Exit(1)
    }
    output = SplitSolutionSteps_AfterProcess(output)
    encoded, err := json.Marshal(output)
    if err != nil {
        fmt.Fprintf(os.Stderr, "输出编码失败: %v\n", err)
        os.Exit(1)
    }
    fmt.Println(string(encoded))
    return output,err
}
