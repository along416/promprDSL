prompt SplitSolutionSteps {
    input {
            Question: string
            Process: string
    }
    
    @latex("严格遵守以下规定设计数学公式使用标准通用的latex格式")
    @kl("数学公式以美元符号包裹，$或$$与公式内容之间不允许有任何空格")
    output {

            Conditions: []string @jsonname("条件")  @latex @kl
            KnowledgePoint: string @jsonname("知识点")  @latex @kl
            ProcessResult: string @jsonname("过程")  @latex @kl 
	}



    system {
       sys_role
       sys_expertise      
    }

    sys_role{
        "你是一个擅长拆分解题步骤的数学老师,"
    }
    sys_expertise {
        if (input.Question == ""){
            "当前任务是将解题步骤进行合理拆分"
        }
        else{
            "当前任务是将解题步骤进行合理拆分2"
        }
    }
    user{
        user_title
        user_content
    }
    user_title {
        "请根据以下输入题目及其解答内容，将完整的解答过程拆分为多个“短链”，每个“短链”包含以下三个要素："
    }
    user_content {
        "条件，知识点，结果"
        if (input.Question != ""){
            "你好"
        }
        else{
            "siuehfebn"
            "siuehfebn"
            "siuehfebn"
        }
        "条件，知识点，结果"
        "题目："
        input.Question
        "过程："
        input.Process
        
        "请将输出内容严格按照以下格式返回："
        []outputspec
        "特别提醒：本题可能涉及 extra_hint，请根据步骤合理提取对应知识点。"
    }

    fix{
        // 用strings.Builder手动替换单反斜杠
        fmt.Println("response:", response)
        var results []SplitSolutionStepsOutputContext
        err := json.Unmarshal([]byte(response), &results)
        if err != nil {
            var buf strings.Builder
            for i := 0; i < len(response); i++ {
                if response[i] == '\\' {
                    // 判断是否有下一个字符
                    if i+1 < len(response) {
                        next := response[i+1]
                        // 如果是两个连续的反斜杠
                        if next == '\\' {
                            // 再判断第三个字符是否存在，且不是字母或反斜杠
                            if i+2 >= len(response) || !(unicode.IsLetter(rune(response[i+2])) || response[i+2] == '\\') {
                                // 变成 4 个斜杠
                                buf.WriteString(`\\\\`)
                            } else {
                                // 保留原样 2 个斜杠
							    buf.WriteString(`\\`)
                                if response[i+3] == '\\' {
                                    i++
                                }
                            }
                            i++ // 跳过下一个斜杠
                        } else if next == '"' {
                            // 保留一个反斜杠
                            buf.WriteByte('\\')
                            i++ // 跳过 "
                        } else {
                            // fmt.Println("last char is \\")
                            // 单独的 \，不是合法转义，变成两个
                            buf.WriteString(`\\`)
                        }
                    } else {
                        // 最后一个字符是反斜杠，补一个
                        buf.WriteString(`\`)
                    }
                } else {
                    buf.WriteByte(response[i])
                }
            }
            fixed := buf.String()
            fmt.Println("fixed:", fixed)
            err := json.Unmarshal([]byte(fixed), &results)
            if err != nil {
                return nil, fmt.Errorf("JSON 解析失败: %w", err)
            }
            return results, nil
        }
        return results, nil

    }
       

    after{
        trueCount := 0
        for _, item := range output {
            if item.ProcessResult!= "" {
                trueCount++
            }
        }
        return output

        
    }

}
