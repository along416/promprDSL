package promptdslcore

import (
	"fmt"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/antlr4-go/antlr/v4"
)

var symbolToImport = map[string]string{
	"fmt.":     "fmt",
	"strings.": "strings",
	"math.":     "math",
	"json.":     "encoding/json",
	"log.":      "log",
	"io.":       "io",
	"os.":       "os",
	// ...
}

//eval

// 构建输出规范文本，用于根据字段列表生成 JSON 字符串表示。
func BuildOutputSpecText(fields []FieldDef) string {
	var b strings.Builder
	b.WriteString("```json\n[\n  {\n")

	for i, f := range fields {
		var example string
		switch f.Type {
		case "string":
			example = "\"\""
		case "int":
			example = "0"
		case "float":
			example = "0.0"
		case "bool":
			example = "false"
		default:
			if strings.HasPrefix(f.Type, "[]") {
				elemType := f.Type[2:]
				switch elemType {
				case "string":
					example = "[\"\"]"
				case "int":
					example = "[0]"
				case "float":
					example = "[0.0]"
				case "bool":
					example = "[false]"
				default:
					example = "[]"
				}
			} else {
				example = "{}"
			}
		}

		// 添加字段及注释
		b.WriteString(fmt.Sprintf("    \"%s\": %s  // %s", f.JsonName, example, strings.Join(f.Annotations, ",")))
		if i < len(fields)-1 {
			b.WriteString(",\n")
		} else {
			b.WriteString("\n")
		}
	}

	b.WriteString("  }\n]\n```")
	return b.String()
}

func GenerateAfterAndFixGoCode(root *RootNode, pkgName string) string {
	var b strings.Builder

	// 写包名和注释
	b.WriteString("// Code generated by PromptDSL. DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", pkgName))

	//import
	afterCode := strings.Join(root.AfterCode, "\n")
	fixCode := strings.Join(root.FixCode, "\n")

	allCode := afterCode + "\n" + fixCode

	pkgs := inferImportsFromCode(allCode)

	// 手动保证 "os" 在包列表里
	requiredPkgs := []string{"os", "fmt"}
	for _, req := range requiredPkgs {
		has := false
		for _, pkg := range pkgs {
			if pkg == req {
				has = true
				break
			}
		}
		if !has {
			pkgs = append(pkgs, req)
		}
	}

	importBlock := renderImportSection(pkgs)
	b.WriteString(importBlock)

	// struct
	b.WriteString("type InputContext struct {\n")
	for _, field := range root.InFields {
		b.WriteString(fmt.Sprintf("    %s %s `json:\"%s\"`\n", field.Name, field.Type, field.JsonName))
	}
	b.WriteString("}\n\n")
	b.WriteString("type OutputContext struct {\n")
	for _, field := range root.OutFields {
		fieldName := capitalizeFirst(field.Name)
		b.WriteString(fmt.Sprintf("    %s %s `json:\"%s\"`\n", fieldName, field.Type, field.JsonName))
	}
	b.WriteString("}\n\n")

	b.WriteString("type FinalContext struct {\n")
	b.WriteString("    Input  InputContext\n")
	b.WriteString("    Output []OutputContext\n") // 注意 Output 是 slice，适配大模型批量返回
	b.WriteString("}\n\n")

	// 写入 After 函数（如果有）
	if strings.TrimSpace(root.AfterCode[0]) != "" {
		b.WriteString("func AfterProcess(output []OutputContext) []OutputContext {\n")
		b.WriteString(root.AfterCode[0])
		b.WriteString("\n}\n\n")
	}

	// 写入 Fix 函数（如果有）
	if strings.TrimSpace(root.FixCode[0]) != "" {
		b.WriteString("func FixProcess(response string) ([]OutputContext ,error){\n")
		b.WriteString(root.FixCode[0])
		b.WriteString("\n}\n")
	}

	// 写 main 函数
	b.WriteString("\nfunc main() {\n")
	// 入口打印
	b.WriteString("    fmt.Fprintln(os.Stderr, \"[main] 程序启动，等待输入...\")\n")
	// b.WriteString("    fmt.Fprintln(os.Stderr, \"[main] 程序启动，等待输入...\")\n\n")

	// b.WriteString("    inputBytes, err := io.ReadAll(os.Stdin)\n")
	// b.WriteString("    if err != nil {\n")
	// b.WriteString("        fmt.Fprintln(os.Stderr, \"读取输入失败:\", err)\n")
	// b.WriteString("        os.Exit(1)\n")
	// b.WriteString("    }\n\n")

	// b.WriteString("    fmt.Fprintf(os.Stderr, \"[main] 收到输入: %s\\n\", string(inputBytes))\n\n")

	// b.WriteString("    // 输出简单 JSON 测试一下 stdout 是否返回\n")
	// b.WriteString("    fmt.Println(`[{\"result\": \"ok\"}]`)\n")

	b.WriteString("    inputBytes, err := os.ReadFile(\"model_output.json\")\n")
	b.WriteString("    if err != nil {\n")
	b.WriteString("        fmt.Fprintf(os.Stderr, \"读取输入失败: %v\\n\", err)\n")
	b.WriteString("        os.Exit(1)\n")
	b.WriteString("    }\n\n")

	hasFix := strings.TrimSpace(fixCode) != ""
	hasAfter := strings.TrimSpace(afterCode) != ""

	if hasFix {
		b.WriteString("    output,err := FixProcess(string(inputBytes))\n")
		b.WriteString("    if err := json.Unmarshal(inputBytes, &output); err != nil {\n")
		b.WriteString("        fmt.Fprintf(os.Stderr, \"解析输入 JSON 失败011111: %v\\n\", err)\n")
		b.WriteString("        os.Exit(1)\n")
		b.WriteString("    }\n")
		if hasAfter {
			b.WriteString("    output = AfterProcess(output)\n")
		}
	} else if hasAfter {
		b.WriteString("    var output []OutputContext\n")
		b.WriteString("    if err := json.Unmarshal(inputBytes, &output); err != nil {\n")
		b.WriteString("        fmt.Fprintf(os.Stderr, \"解析输入 JSON 失败011111: %v\\n\", err)\n")
		b.WriteString("        os.Exit(1)\n")
		b.WriteString("    }\n")
		b.WriteString("    output = AfterProcess(output)\n")
	} else {
		b.WriteString("    fmt.Println(\"未定义 FixProcess 或 AfterProcess\")\n")
		b.WriteString("    return\n")
	}

	b.WriteString("\n    encoded, err := json.Marshal(output)\n")
	b.WriteString("    if err != nil {\n")
	b.WriteString("        fmt.Fprintf(os.Stderr, \"输出编码失败: %v\\n\", err)\n")
	b.WriteString("        os.Exit(1)\n")
	b.WriteString("}\n")
	b.WriteString("    fmt.Println(string(encoded))\n")
	b.WriteString("}\n")

	return b.String()
}
func GenerateFIX(root *RootNode, pkgName string) string {
	// 写入 Fix 函数（如果有）
	var b strings.Builder
	if strings.TrimSpace(root.FixCode[0]) != "" {
		b.WriteString("function FixProcess(response) {\n")
		b.WriteString(root.FixCode[0])
		b.WriteString("\n};\n")
	}
	return b.String()
}
func getCurrentPackageName() string {
	_, file, _, ok := runtime.Caller(1)
	if !ok {
		return "main"
	}
	// 获取路径中的目录名作为“包名”
	dir := filepath.Base(filepath.Dir(file))
	return dir
}
func extractRawText(ctx antlr.ParserRuleContext, tokens *antlr.CommonTokenStream) []string {
	startIdx := ctx.GetStart().GetTokenIndex()
	stopIdx := ctx.GetStop().GetTokenIndex()

	// 获取完整 token 列表
	allTokens := tokens.GetAllTokens()

	// 切片截取 ctx 范围内的 token
	if startIdx < 0 || stopIdx >= len(allTokens) || startIdx > stopIdx {
		return nil
	}

	var builder strings.Builder
	for _, tok := range allTokens[startIdx : stopIdx+1] {
		builder.WriteString(tok.GetText())
	}
	code := builder.String()
	code = strings.TrimPrefix(code, "<after>")
	code = strings.TrimSuffix(code, "</after>")
	code = strings.TrimPrefix(code, "<fix>")
	code = strings.TrimSuffix(code, "</fix>")
	return []string{code}
}

func capitalizeFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
func renderImportSection(pkgs []string) string {
	if len(pkgs) == 0 {
		return ""
	}
	var b strings.Builder
	b.WriteString("import (\n")
	for _, pkg := range pkgs {
		b.WriteString(fmt.Sprintf("\t\"%s\"\n", pkg))
	}
	b.WriteString(")\n\n")
	return b.String()
}
func inferImportsFromCode(code string) []string {
	importSet := map[string]struct{}{}

	for prefix, pkg := range symbolToImport {
		if strings.Contains(code, prefix) {
			importSet[pkg] = struct{}{}
		}
	}

	var imports []string
	for pkg := range importSet {
		imports = append(imports, pkg)
	}
	// sort.Strings(imports) // 可选：让 import 有序
	return imports
}
