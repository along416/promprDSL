// Code generated by PromptDSL. DO NOT EDIT.
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"
)

type InputContext struct {
	question string `json:"question"`
	process  string `json:"process"`
}

type OutputContext struct {
	Conditions     []string `json:"条件"`
	KnowledgePoint string   `json:"知识点"`
	ProcessResult  string   `json:"过程"`
}

type FinalContext struct {
	Input  InputContext
	Output OutputContext
}

func AfterProcess(output OutputContext) OutputContext {

	if strings.TrimSpace(output.ProcessResult) != "" {
		// 做些统计或操作
	}
	return output

}

func FixProcess(response string) (OutputContext, error) {

	var output OutputContext
	err := json.Unmarshal([]byte(response), &output)
	if err != nil {
		return OutputContext{}, err
	}

	if strings.TrimSpace(output.KnowledgePoint) == "" {
		output.KnowledgePoint = "默认知识点"
	}

	for j, cond := range output.Conditions {
		output.Conditions[j] = strings.TrimSpace(cond)
	}

	// 其他逻辑...

	return output, nil

}

func main() {
	fmt.Fprintln(os.Stderr, "[main] 程序启动，等待输入...")
	inputBytes, err := os.ReadFile("model_output.json")
	if err != nil {
		fmt.Fprintf(os.Stderr, "读取输入失败: %v\n", err)
		os.Exit(1)
	}

	output, err := FixProcess(string(inputBytes))
	if err := json.Unmarshal(inputBytes, &output); err != nil {
		fmt.Fprintf(os.Stderr, "解析输入 JSON 失败011111: %v\n", err)
		os.Exit(1)
	}
	output = AfterProcess(output)

	encoded, err := json.Marshal(output)
	if err != nil {
		fmt.Fprintf(os.Stderr, "输出编码失败: %v\n", err)
		os.Exit(1)
	}
	fmt.Println(string(encoded))
}
