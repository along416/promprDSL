// Code generated by PromptDSL. DO NOT EDIT.
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"math"
	"os"
	"strings"
)

type InputContext struct {
	question string `json:"question"`
	process  string `json:"process"`
}

type OutputContext struct {
	Conditions     []string `json:"条件"`
	KnowledgePoint string   `json:"知识点"`
	ProcessResult  string   `json:"过程"`
}

type FinalContext struct {
	Input  InputContext
	Output []OutputContext
}

func AfterProcess(output []OutputContext) []OutputContext {

	trueCount := 0
	for _, item := range output {
		if item.ProcessResult != "" {
			trueCount++
		}
	}
	return output

}

func FixProcess(response string) ([]OutputContext, error) {

	var output []OutputContext

	// 解析 JSON 字符串
	err := json.Unmarshal([]byte(response), &output)
	if err != nil {

		return nil, err
	}

	for i := range output {
		// 如果知识点为空，填入默认值
		if strings.TrimSpace(output[i].KnowledgePoint) == "" {
			output[i].KnowledgePoint = "默认知识点"
		}

		// 清理条件中的空格
		for j, cond := range output[i].Conditions {
			output[i].Conditions[j] = strings.TrimSpace(cond)
		}

		// 示例逻辑：根据知识点长度进行一些微调检查
		delta := math.Abs(float64(len(output[i].KnowledgePoint)) - 5.0)
		if delta > 10 {
		}
	}

	return output, err

}

func main() {
	fmt.Fprintln(os.Stderr, "[main] 程序启动，等待输入...")
	inputBytes, err := io.ReadAll(os.Stdin)
	if err != nil {
		fmt.Fprintf(os.Stderr, "读取输入失败: %v\n", err)
		os.Exit(1)
	}

	output, err := FixProcess(string(inputBytes))
	if err := json.Unmarshal(inputBytes, &output); err != nil {
		fmt.Fprintf(os.Stderr, "解析输入 JSON 失败011111: %v\n", err)
		os.Exit(1)
	}
	output = AfterProcess(output)

	encoded, err := json.Marshal(output)
	if err != nil {
		fmt.Fprintf(os.Stderr, "输出编码失败: %v\n", err)
		os.Exit(1)
	}
	fmt.Println(string(encoded))
}
