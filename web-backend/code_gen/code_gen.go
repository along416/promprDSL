// Code generated by PromptDSL. DO NOT EDIT.
package codegen

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"unicode"
	"service"
)

type InputContext struct {
	question string `json:"question"`
	process  string `json:"process"`
}

type OutputContext struct {
	Conditions     []string `json:"条件"`
	KnowledgePoint string   `json:"知识点"`
	ProcessResult  string   `json:"过程"`
}

type FinalContext struct {
	Input  InputContext
	Output []OutputContext
}
func sysgen()string{

	return ""
}
func usergen(a Node)string{
	var b strings.Builder
	if(input.question!=""){
		for _,v range a.IfNode.then
		b.WriteString(v)//if结点的then
	}else{
		b.WriteString(v)//if结点的then
	}
	b.WriteString("请根据以下输入题目及其解答内容，将完整的解答过程拆分为多个“短链”，每个“短链”包含以下三个要素")
	b.WriteString("题目")
	b.WriteString(input.question)
	b.WriteString("题目")
	b.WriteString(input.question)
	
	return ""
}
func AfterProcess(output []OutputContext) []OutputContext {

	trueCount := 0
	for _, item := range output {
		if item.ProcessResult != "" {
			trueCount++
		}
	}
	return output

}

func FixProcess(response string) ([]OutputContext, error) {

	// 用strings.Builder手动替换单反斜杠
	fmt.Println("response:", response)
	var results []OutputContext
	// err := json.Unmarshal([]byte(response), &results)
	if true{
		var buf strings.Builder
		for i := 0; i < len(response); i++ {
			if response[i] == '\\' {
				// 判断是否有下一个字符
				if i+1 < len(response) {
					next := response[i+1]
					// 如果是两个连续的反斜杠
					if next == '\\' {
						// 再判断第三个字符是否存在，且不是字母或反斜杠
						if i+2 >= len(response) || !(unicode.IsLetter(rune(response[i+2])) || response[i+2] == '\\') {
							// 变成 4 个斜杠
							buf.WriteString(`\\\\`)
						} else {
							// 保留原样 2 个斜杠
							buf.WriteString(`\\`)
							if response[i+3] == '\\' {
								i++
							}
						}
						i++ // 跳过下一个斜杠
					} else if next == '"' {
						// 保留一个反斜杠
						buf.WriteByte('\\')
						i++ // 跳过 "
					} else {
						// fmt.Println("last char is \\")
						// 单独的 \，不是合法转义，变成两个
						buf.WriteString(`\\`)
					}
				} else {
					// 最后一个字符是反斜杠，补一个
					buf.WriteString(`\`)
				}
			} else {
				buf.WriteByte(response[i])
			}
		}
		fixed := buf.String()
		fmt.Println("fixed:", fixed)
		err := json.Unmarshal([]byte(fixed), &results)
		if err != nil {
			return nil, fmt.Errorf("JSON 解析失败: %w", err)
		}
		return results, nil
	}
	return results, nil

}

func prompt1excecute (input InputContext)([]OutputContext, error){
	fmt.Fprintln(os.Stderr, "[main] 程序启动，等待输入...")

	sys:= sysgen()
	user:= usergen()

	apiKey := "sk-02e496929ecc485796d29bd94e7ce371"
	llm := service.NewLLMClient(apiKey)
	result, err := llm.GeneratePromptResponse(sys, user)

	output, err := FixProcess(string(result))
	if err != nil {
		fmt.Fprintf(os.Stderr, "解析输入 JSON 失败011111: %v\n", err)
		os.Exit(1)
	}
	output = AfterProcess(output)

	encoded, err := json.Marshal(output)
	if err != nil {
		fmt.Fprintf(os.Stderr, "输出编码失败: %v\n", err)
		os.Exit(1)
	}
	fmt.Println(string(encoded))
	return output,err
}

func prompt2excecute (input []OutputContext)([]OutputContext, error){
	fmt.Fprintln(os.Stderr, "[main] 程序启动，等待输入...")
	inputBytes, err := os.ReadFile("../model_output.json")
	if err != nil {
		fmt.Fprintf(os.Stderr, "读取输入失败: %v\n", err)
		os.Exit(1)
	}

	output, err := FixProcess(string(inputBytes))
	if err != nil {
		fmt.Fprintf(os.Stderr, "解析输入 JSON 失败011111: %v\n", err)
		os.Exit(1)
	}
	output = AfterProcess(output)

	encoded, err := json.Marshal(output)
	if err != nil {
		fmt.Fprintf(os.Stderr, "输出编码失败: %v\n", err)
		os.Exit(1)
	}
	fmt.Println(string(encoded))
	return output,err
}

func workflow (input map[string]string){
	var input1 InputContext

	pronput1output,err:=prompt1excecute(input1)

	pronput2output,err:=prompt2excecute(pronput1output)

	// pronput2output:=prompt2excecute(pronput1output)
}
