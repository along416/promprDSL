// Code generated by PromptDSL. DO NOT EDIT.
package main

import (
	"encoding/json"
	"fmt"
	"strings"
	"unicode"
	// "os"
)

type InputContext struct {
    question string `json:"question"`
    process string `json:"process"`
}

type OutputContext struct {
    Conditions []string `json:"条件"`
    KnowledgePoint string `json:"知识点"`
    ProcessResult string `json:"过程"`
}

type FinalContext struct {
    Input  InputContext
    Output []OutputContext
}

func Gensys(input InputContext) string {
    var b strings.Builder
    return b.String()

}

func GenUser(input InputContext) string {
    var b strings.Builder
    if (input.question!="") {
        b.WriteString("你好\n")
    } else {
        b.WriteString("siuehfebn\n")
        b.WriteString("siuehfebn\n")
        b.WriteString("siuehfebn\n")
    }
    b.WriteString("请根据以下输入题目及其解答内容，将完整的解答过程拆分为多个“短链”，每个“短链”包含以下三个要素：\n")
    b.WriteString("条件，知识点，结果\n")
    b.WriteString("题目：\n")
    b.WriteString(input.question)
    b.WriteString("过程：\n")
    b.WriteString(input.process)
    b.WriteString("请将输出内容严格按照以下格式返回：\n")
        b.WriteString("```json\n")
    b.WriteString("[\n")
    b.WriteString("  {\n")
    b.WriteString("    \"条件\": [\"\"]  // 严格遵守以下规定设计数学公式使用标准通用的latex格式,数学公式以美元符号包裹，$或$$与公式内容之间不允许有任何空格,\n")
    b.WriteString("    \"知识点\": \"\"  // 严格遵守以下规定设计数学公式使用标准通用的latex格式,数学公式以美元符号包裹，$或$$与公式内容之间不允许有任何空格,\n")
    b.WriteString("    \"过程\": \"\"  // 严格遵守以下规定设计数学公式使用标准通用的latex格式,数学公式以美元符号包裹，$或$$与公式内容之间不允许有任何空格\n")
    b.WriteString("  }\n")
    b.WriteString("]\n")
    b.WriteString("```\n")

    b.WriteString("特别提醒：本题可能涉及 extra_hint，请根据步骤合理提取对应知识点。\n")
    return b.String()

}

func AfterProcess(output []OutputContext) []OutputContext {

        trueCount := 0
        for _, item := range output {
            if item.ProcessResult!= "" {
                trueCount++
            }
        }
        return output
    
}

func FixProcess(response string) ([]OutputContext ,error){

       	// 用strings.Builder手动替换单反斜杠
        fmt.Println("response:", response)
        var results []OutputContext
        err := json.Unmarshal([]byte(response), &results)
        if err != nil {
            var buf strings.Builder
            for i := 0; i < len(response); i++ {
                if response[i] == '\\' {
                    // 判断是否有下一个字符
                    if i+1 < len(response) {
                        next := response[i+1]
                        // 如果是两个连续的反斜杠
                        if next == '\\' {
                            // 再判断第三个字符是否存在，且不是字母或反斜杠
                            if i+2 >= len(response) || !(unicode.IsLetter(rune(response[i+2])) || response[i+2] == '\\') {
                                // 变成 4 个斜杠
                                buf.WriteString(`\\\\`)
                            } else {
                                // 保留原样 2 个斜杠
							    buf.WriteString(`\\`)
                                if response[i+3] == '\\' {
                                    i++
                                }
                            }
                            i++ // 跳过下一个斜杠
                        } else if next == '"' {
                            // 保留一个反斜杠
                            buf.WriteByte('\\')
                            i++ // 跳过 "
                        } else {
                            // fmt.Println("last char is \\")
                            // 单独的 \，不是合法转义，变成两个
                            buf.WriteString(`\\`)
                        }
                    } else {
                        // 最后一个字符是反斜杠，补一个
                        buf.WriteString(`\`)
                    }
                } else {
                    buf.WriteByte(response[i])
                }
            }
            fixed := buf.String()
            fmt.Println("fixed:", fixed)
            err := json.Unmarshal([]byte(fixed), &results)
            if err != nil {
                return nil, fmt.Errorf("JSON 解析失败: %w", err)
            }
            return results, nil
        }
        return results, nil
    
}

func main() {
 var input InputContext

    input.process="第一小题求学生的接受能力最强其实就是要求分段函数的最大值，方法是分别求出各段的最大值取其最大即可。\n第二小题比较5分钟和20分钟学生的接受能力何时强，方法是把x=5代入第一段函数中，而x=20要代入到第二段函数中，比较大小即可。不同的自变量代入相应的解析式才能符合要求"
    input.question="通过研究学生的学习行为，心理学家发现，学生接受能力依赖于老师引入概念和描述问题所用的时间，讲座开始时，学生的兴趣增长，中间有一段不太长的时间，学生的兴趣保持理想的状态，随后学生注意力开始分散．分析结果和实验表明，用f（x）表示学生掌握和接受概念的能力（f（x）值越大，表示接受能力越强），x表示提出和讲授概念的时间（单位：分），可以有以下的公式：\n$$f(x) = \\begin{cases} -0.1x^2 + 2.6x + 43 & (0 < x \\le 10) \\\\ 59 & (10 < x \\le 16) \\\\ -3x + 107 & (16 < x \\le 30) \\end{cases}$$\n（1）开讲多少分钟后，学生的接受能力最强？能维持多少时间？\n（2）开讲5分钟与开讲20分钟比较，学生的接受能力何时强一些？"
    // sys:= Gensys(input)
    user:= GenUser(input)
    fmt.Println("user:",user)
}
